import React, { useEffect, useMemo, useState, useCallback } from "react";

/**
 * SkillRPG — локальний трекер скілів (UA, 5 рівнів)
 * Рефактор: стабільна версія без синтаксичних помилок
 */

// ======================== CONSTANTS ========================
const APP_VERSION = 2; // bump при змінах схеми
const STORAGE_KEY = "skillrpg_ua_v2"; // новий ключ сховища для чистого seed

const TIER_TITLES = ["Новачок", "Початківець", "Практик", "Просунутий", "Експерт"];
const BASE_OBJECTIVE_XP = 10;
const SYNERGY_BONUS_PER_SPHERE = 0.15; // 15%
const MAX_SYNERGY_BONUS = 0.45; // 45%

const OUTCOME_MULTIPLIER: Record<string, number> = { success: 1.0, partial: 0.6, fail: 0.2 };
const EVIDENCE_MULTIPLIER: Record<string, number> = { report: 2.5, repo: 2.0, log: 1.5, photo: 1.0 };

function uid() { return Math.random().toString(36).slice(2, 10); }
const clamp = (v: number, a: number, b: number) => Math.max(a, Math.min(b, v));

// ======================== SAMPLE DATA (SEED) ========================
function makeSkill(prefix: string, sphereId: string, name: string) {
  return {
    id: `${prefix}${name}`,
    sphereId,
    name,
    description: "",
    synergies: [] as string[],
    tiers: [1,2,3,4,5].map((lvl) => ({ level: lvl, title: TIER_TITLES[lvl-1], objectives: [] as any[] }))
  };
}

const sampleData = {
  version: APP_VERSION,
  spheres: [
    { id: "sphere_general", name: "Загальновійськові навички", color: "#556B2F" },
    { id: "sphere_uav", name: "Робота з БПЛА", color: "#3FA7D6" },
    { id: "sphere_assembly", name: "Монтаж / Збірка", color: "#5A6066" },
    { id: "sphere_engineering", name: "Інженерія / Технічний дизайн", color: "#E89C2E" },
    { id: "sphere_telecom", name: "Телекомунікації", color: "#9B4F96" },
    { id: "sphere_programming", name: "Програмування", color: "#0047AB" },
    { id: "sphere_analytics", name: "Аналітика / Обробка даних", color: "#168F8F" },
    { id: "sphere_cognitive", name: "Когнітивні навички / Прийняття рішень", color: "#D4AF37" }
  ],
  skills: [
    // Загальновійськові
    ...[
      "Водіння автотранспорту","Навички роботи з ПК","Робота у офісних програмах","Навігація / робота з картами",
      "Тактична медицина (ASM/CLS)","Вогнева підготовка","Інженерна підготовка","Тактична підготовка",
      "Маскування та приховане пересування","Розвідка та спостереження"
    ].map((name) => makeSkill("skill_general_", "sphere_general", name)),

    // Робота з БПЛА
    ...[
      "Пілотування FPV","Пілотування коптера","Пілотування літака / крила","Навички посадки БПЛА за складних умов",
      "Знання фізики руху БПЛА","Польовий ремонт та діагностика БПЛА","Створення маршрутів вручну",
      "Створення маршрутів у ПЗ","Робота у Mission Planner","Аналіз телеметрії / логів польоту"
    ].map((name) => makeSkill("skill_uav_", "sphere_uav", name)),

    // Монтаж / Збірка
    ...["Пайка","Кабелювання","Механічна збірка","Слюсарні роботи","Зварювання (електрод / MIG / TIG / газ)","Робота з АКБ"].map((name)=>makeSkill("skill_assembly_","sphere_assembly",name)),

    // Інженерія / Технічний дизайн
    ...["Схемотехніка","Радіосистеми та антени","Bring-up та налагодження пристроїв","Тестування та валідація пристроїв","Проєктування механічних деталей / 3D-креслення"].map((name)=>makeSkill("skill_engineering_","sphere_engineering",name)),

    // Телекомунікації
    ...["Мережі та інфраструктура зв'язку","SDR та РЧ аналіз"].map((name)=>makeSkill("skill_telecom_","sphere_telecom",name)),

    // Програмування
    ...["Embedded-програмування","Архітектура ПЗ та дизайн систем","Скриптування (Python/Lua)","Автоматизація / CI / тести","Машинне навчання та ШІ (практичне застосування)","Бази даних"].map((name)=>makeSkill("skill_prog_","sphere_programming",name)),

    // Аналітика / Обробка даних
    ...["OSINT","Обробка геоприв'язаних даних (QGIS/ArcGIS)","Побудова моделей / симуляцій","Візуалізація даних","Робота з великими наборами даних (ETL)"].map((name)=>makeSkill("skill_analytics_","sphere_analytics",name)),

    // Когнітивні
    ...["Теорія пізнання","Когнітивні викривлення","Рішення в умовах невизначеності"].map((name)=>makeSkill("skill_cognitive_","sphere_cognitive",name))
  ],
  missions: [] as any[]
};

// ======================== STORAGE / MIGRATIONS ========================
function migrate(data: any) {
  if (!data || typeof data !== "object") return sampleData;
  if (!Array.isArray(data.spheres) || data.spheres.length === 0) data.spheres = sampleData.spheres;
  if (!Array.isArray(data.skills)) data.skills = sampleData.skills;
  if (!Array.isArray(data.missions)) data.missions = [];
  data.version = APP_VERSION;
  return data;
}

function loadData() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return sampleData;
    const parsed = JSON.parse(raw);
    return migrate(parsed);
  } catch (e) {
    console.warn("Помилка читання даних, використовую зразок", e);
    return sampleData;
  }
}

const saveData = (data: any) => localStorage.setItem(STORAGE_KEY, JSON.stringify({ ...data, version: APP_VERSION }));
function hardResetData() {
  try { localStorage.removeItem(STORAGE_KEY); } catch (_) {}
  return JSON.parse(JSON.stringify(sampleData));
}

// ======================== XP HELPERS ========================
function calcSynergyMultiplier(skill: any, spheres: any[]) {
  const ids = skill.synergies || [];
  if (!ids.length) return 1;
  const unique = ids.filter((id: string) => spheres.some((s) => s.id === id));
  const bonus = Math.min(unique.length * SYNERGY_BONUS_PER_SPHERE, MAX_SYNERGY_BONUS);
  return 1 + bonus;
}

function calcSkillXP(skill: any, spheres: any[]) {
  const mult = calcSynergyMultiplier(skill, spheres);
  let earned = 0, possible = 0;
  for (const tier of skill.tiers) {
    for (const obj of tier.objectives) {
      const base = obj.xp ?? BASE_OBJECTIVE_XP;
      const adj = Math.round(base * mult);
      possible += adj;
      if (obj.done) earned += adj;
    }
  }
  const percent = possible ? Math.round((earned / possible) * 100) : 0;
  return { earned, possible, percent, mult };
}

function tierCompletion(tier: any) {
  const total = tier.objectives.length;
  const done = tier.objectives.filter((o: any) => o.done).length;
  return total ? Math.round((done / total) * 100) : 0;
}

function evidenceQualityMultiplier(type: string) { return EVIDENCE_MULTIPLIER[type] ?? 1.0; }

function calcMissionXP(mission: any, spheres: any[]) {
  const base = 10 * (
    0.3 * (mission.difficulty || 1) +
    0.3 * (mission.impact || 1) +
    0.2 * (mission.ambiguity || 1) +
    0.1 * (mission.time_pressure || 1) +
    0.1 * (mission.autonomy || 1)
  );
  const outcome = OUTCOME_MULTIPLIER[mission.outcome || "success"] || 1.0;
  const evMult = evidenceQualityMultiplier(mission.evidence_type || "photo");
  const synergy = (() => {
    const ids = mission.spheres || [];
    const unique = ids.filter((id: string) => spheres.some((s) => s.id === id));
    const bonus = Math.min(unique.length * SYNERGY_BONUS_PER_SPHERE, MAX_SYNERGY_BONUS);
    return 1 + bonus;
  })();
  return Math.round(base * outcome * evMult * synergy);
}

// ======================== UI PRIMITIVES ========================
function Button({ children, onClick, variant = "primary", disabled }: any) {
  const cls = variant === "primary"
    ? "px-3 py-1.5 rounded-md bg-blue-600 text-white text-sm shadow disabled:opacity-50"
    : variant === "ghost"
      ? "px-3 py-1.5 rounded-md text-sm border disabled:opacity-50"
      : "px-3 py-1.5 rounded-md text-sm bg-gray-100 disabled:opacity-50";
  return (
    <button onClick={onClick} disabled={disabled} className={cls}>{children}</button>
  );
}

function Pill({ children, color }: any) {
  return (
    <span className="inline-flex items-center rounded-full px-2 py-1 text-xs font-medium border" style={{ borderColor: color, color }}>{children}</span>
  );
}

function ProgressBar({ percent }: any) {
  return (
    <div className="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
      <div className="h-2 rounded-full" style={{ width: `${clamp(percent,0,100)}%`, background: "linear-gradient(90deg, #22c55e, #3b82f6)" }} />
    </div>
  );
}

function NumberBadge({ children }: any) {
  return <span className="inline-block min-w-6 text-center text-xs rounded-md bg-gray-100 px-2 py-1">{children}</span>;
}

// ======================== MAIN APP ========================
export default function App() {
  const [data, setData] = useState(loadData);
  const [selectedSphereId, setSelectedSphereId] = useState<string>(() => (loadData().spheres[0]?.id || ""));
  const [selectedSkillId, setSelectedSkillId] = useState<string>("");
  const [importText, setImportText] = useState<string>("");
  const [viewOnly, setViewOnly] = useState<boolean>(false);

  useEffect(() => { saveData(data); }, [data]);

  const spheres = data.spheres;
  const selectedSphere = spheres.find((s: any) => s.id === selectedSphereId) || spheres[0];
  const sphereSkills = useMemo(() => data.skills.filter((k: any) => k.sphereId === selectedSphere?.id), [data.skills, selectedSphere]);
  const selectedSkill = data.skills.find((k: any) => k.id === selectedSkillId) || sphereSkills[0];

  // overall stats
  const overall = useMemo(() => {
    let earned = 0, possible = 0;
    for (const sk of data.skills) {
      const { earned: e, possible: p } = calcSkillXP(sk, spheres);
      earned += e; possible += p;
    }
    const percent = possible ? Math.round((earned / possible) * 100) : 0;
    return { earned, possible, percent };
  }, [data.skills, spheres]);

  // === callbacks ===
  const addSkill = useCallback(() => {
    if (!selectedSphere || viewOnly) return;
    const name = prompt("Назва скіла?");
    if (!name) return;
    const newSkill = makeSkill(`skill_${selectedSphere.id}_`, selectedSphere.id, name);
    setData((d: any) => ({ ...d, skills: [...d.skills, newSkill] }));
    setSelectedSkillId(newSkill.id);
  }, [selectedSphere, viewOnly]);

  const addObjective = useCallback((skillId: string, tierLevel: number) => {
    if (viewOnly) return;
    setData((d: any) => {
      const skills = d.skills.map((sk: any) => {
        if (sk.id !== skillId) return sk;
        const tiers = sk.tiers.map((t: any) => {
          if (t.level !== tierLevel) return t;
          const text = prompt("Сформулюй об'єктив (має бути перевіряємим)");
          if (!text) return t;
          return { ...t, objectives: [...t.objectives, { id: uid(), text, done: false, evidence: "", xp: BASE_OBJECTIVE_XP }] };
        });
        return { ...sk, tiers };
      });
      return { ...d, skills };
    });
  }, [viewOnly]);

  const patchSkill = useCallback((skillId: string, patch: any) => {
    if (viewOnly) return;
    setData((d: any) => ({ ...d, skills: d.skills.map((sk: any) => (sk.id === skillId ? { ...sk, ...patch } : sk)) }));
  }, [viewOnly]);

  const toggleObjective = useCallback((skillId: string, tierLevel: number, objectiveId: string, field: string, value: any) => {
    if (viewOnly) return;
    setData((d: any) => {
      const skills = d.skills.map((sk: any) => {
        if (sk.id !== skillId) return sk;
        const tiers = sk.tiers.map((t: any) => {
          if (t.level !== tierLevel) return t;
          const objectives = t.objectives.map((o: any) => (o.id === objectiveId ? { ...o, [field]: value } : o));
          return { ...t, objectives };
        });
        return { ...sk, tiers };
      });
      return { ...d, skills };
    });
  }, [viewOnly]);

  const toggleSynergy = useCallback((skill: any, sphereId: string) => {
    if (viewOnly) return;
    const set = new Set(skill.synergies || []);
    if (set.has(sphereId)) set.delete(sphereId); else set.add(sphereId);
    patchSkill(skill.id, { synergies: Array.from(set) });
  }, [patchSkill, viewOnly]);

  const exportJSON = useCallback(() => {
    const blob = new Blob([JSON.stringify({ ...data, version: APP_VERSION }, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = `skillrpg_${new Date().toISOString().slice(0,10)}.json`; a.click();
    URL.revokeObjectURL(url);
  }, [data]);

  const hardResetNow = useCallback(() => {
    const fresh = hardResetData();
    setData(fresh);
    setSelectedSphereId(fresh.spheres[0]?.id || "");
    setSelectedSkillId("");
    alert("Дані очищено. Завантажено новий seed (v2).");
  }, []);

  // ======================== RENDER ========================
  return (
    <div className="min-h-screen bg-white text-gray-800">
      <header className="sticky top-0 z-10 bg-white/90 backdrop-blur border-b">
        <div className="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="w-2.5 h-6 rounded-sm bg-gradient-to-b from-blue-500 via-green-500 to-purple-500" />
            <h1 className="text-lg font-semibold">SkillRPG — локальний трекер скілів (UA, 5 рівнів)</h1>
          </div>
          <div className="flex items-center gap-2">
            <Button onClick={() => setViewOnly(v => !v)} variant="ghost">{viewOnly ? "Режим: Перегляд" : "Режим: Редагування"}</Button>
            <Button onClick={addSkill}>+ Додати скіл у сфері</Button>
            <Button onClick={exportJSON} variant="ghost">Експорт JSON</Button>
            <Button onClick={hardResetNow} variant="ghost">Скинути дані</Button>
          </div>
        </div>
      </header>

      <main className="max-w-7xl mx-auto p-4 grid grid-cols-12 gap-4">
        {/* Сфери */}
        <aside className="col-span-12 lg:col-span-3 border rounded-xl p-3">
          <h2 className="font-semibold mb-3">Сфери</h2>
          <ul className="space-y-2">
            {spheres.map((s: any) => (
              <li key={s.id}>
                <button className={`w-full text-left px-3 py-2 rounded-lg border transition ${selectedSphere?.id === s.id ? "bg-gray-50 border-gray-300" : "hover:bg-gray-50"}`} onClick={() => { setSelectedSphereId(s.id); setSelectedSkillId(""); }}>
                  <div className="flex items-center justify-between">
                    <span className="font-medium">{s.name}</span>
                    <span className="w-3 h-3 rounded-full" style={{ background: s.color }} />
                  </div>
                </button>
              </li>
            ))}
          </ul>

          <div className="mt-6">
            <h3 className="text-sm font-medium mb-1">Загальний прогрес</h3>
            <ProgressBar percent={overall.percent} />
            <div className="text-xs text-gray-500 mt-1">XP: {overall.earned} / {overall.possible}</div>
          </div>

          <div className="mt-6 border-t pt-3">
            <h3 className="text-sm font-medium mb-1">Імпорт JSON</h3>
            <textarea value={importText} onChange={(e) => setImportText(e.target.value)} placeholder="Встав JSON сюди" className="w-full h-24 border rounded-md p-2 text-sm" />
            <div className="flex gap-2 mt-2">
              <Button onClick={() => {
                try {
                  const parsed = JSON.parse(importText);
                  if (!parsed.spheres || !parsed.skills) throw new Error("Некоректна структура");
                  setData(migrate(parsed));
                  setImportText("");
                  alert("Імпортовано");
                } catch (e: any) {
                  alert("Помилка імпорту: " + e.message);
                }
              }}>Імпорт</Button>
              <Button onClick={() => setImportText("")} variant="ghost">Очистити</Button>
            </div>
          </div>
        </aside>

        {/* Скіли у сфері */}
        <section className="col-span-12 lg:col-span-4 border rounded-xl p-3">
          <h2 className="font-semibold mb-3">Скіли у сфері: {selectedSphere?.name}</h2>
          {sphereSkills.length === 0 ? (
            <div className="text-sm text-gray-500">У цій сфері поки немає скілів.</div>
          ) : (
            <ul className="space-y-2">
              {sphereSkills.map((k: any) => {
                const { percent, earned, possible } = calcSkillXP(k, spheres);
                return (
                  <li key={k.id}>
                    <button className={`w-full text-left p-3 rounded-lg border transition ${selectedSkill?.id === k.id ? "bg-gray-50 border-gray-300" : "hover:bg-gray-50"}`} onClick={() => setSelectedSkillId(k.id)}>
                      <div className="flex items-start justify-between gap-2">
                        <div>
                          <div className="font-medium">{k.name}</div>
                          {k.description && <div className="text-xs text-gray-500 mt-0.5">{k.description}</div>}
                          <div className="mt-1 flex gap-1 flex-wrap">
                            <NumberBadge>{percent}%</NumberBadge>
                            {(k.synergies || []).map((sid: string) => {
                              const sph = spheres.find((s: any) => s.id === sid);
                              return sph ? <Pill key={sid} color={sph.color}>{sph.name}</Pill> : null;
                            })}
                          </div>
                        </div>
                        <div className="min-w-36">
                          <ProgressBar percent={percent} />
                          <div className="text-[11px] text-gray-500 mt-1 text-right">XP {earned}/{possible}</div>
                        </div>
                      </div>
                    </button>
                  </li>
                );
              })}
            </ul>
          )}
        </section>

        {/* Деталі скіла */}
        <section className="col-span-12 lg:col-span-5 border rounded-xl p-3">
          {!selectedSkill ? (
            <div className="text-sm text-gray-500">Оберіть скіл</div>
          ) : (
            <div className="space-y-3">
              <div className="flex items-start justify-between gap-3">
                <div className="flex-1">
                  <input className="w-full text-base font-semibold outline-none bg-transparent disabled:text-gray-600" value={selectedSkill.name} disabled={viewOnly} onChange={(e) => patchSkill(selectedSkill.id, { name: e.target.value })} />
                  <textarea className="w-full text-sm text-gray-700 mt-1 outline-none bg-transparent border rounded-md p-2 disabled:text-gray-600" placeholder="Опис скіла" value={selectedSkill.description} disabled={viewOnly} onChange={(e) => patchSkill(selectedSkill.id, { description: e.target.value })} />
                </div>
                <div className="text-right min-w-40">
                  {(() => {
                    const { earned, possible, mult, percent } = calcSkillXP(selectedSkill, spheres);
                    return (
                      <>
                        <div className="text-sm font-medium">Прогрес</div>
                        <ProgressBar percent={percent} />
                        <div className="text-[11px] text-gray-500 mt-1">XP {earned}/{possible}</div>
                        <div className="text-[11px] text-gray-500">Множник синергії: ×{mult.toFixed(2)}</div>
                      </>
                    );
                  })()}
                </div>
              </div>

              <div className="flex flex-wrap items-center gap-2">
                <span className="text-sm font-medium">Синергії:</span>
                {spheres.map((s: any) => (
                  <label key={s.id} className="inline-flex items-center gap-1 text-sm opacity-100">
                    <input type="checkbox" className="accent-blue-600" checked={selectedSkill.synergies?.includes(s.id) || false} disabled={viewOnly} onChange={() => toggleSynergy(selectedSkill, s.id)} />
                    <span className="select-none" style={{ color: s.color }}>{s.name}</span>
                  </label>
                ))}
              </div>

              <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                {selectedSkill.tiers.map((t: any) => (
                  <div key={t.level} className="border rounded-lg p-3">
                    <div className="flex items-center justify-between">
                      <div className="font-medium">Рівень {t.level}: {t.title}</div>
                      <NumberBadge>{tierCompletion(t)}%</NumberBadge>
                    </div>

                    <ul className="mt-2 space-y-2">
                      {t.objectives.length === 0 && (
                        <li className="text-xs text-gray-500">Об'єктивів ще немає.</li>
                      )}
                      {t.objectives.map((o: any) => (
                        <li key={o.id} className="border rounded-md p-2">
                          <div className="flex items-start gap-2">
                            <input type="checkbox" className="mt-1 accent-green-600" checked={o.done} disabled={viewOnly} onChange={(e) => toggleObjective(selectedSkill.id, t.level, o.id, "done", e.target.checked)} />
                            <div className="flex-1">
                              <div className={`text-sm ${o.done ? "line-through text-gray-500" : ""}`}>{o.text}</div>
                              <div className="flex items-center gap-2 mt-1">
                                <input className="w-full text-xs border rounded px-2 py-1 disabled:text-gray-600" placeholder="Посилання/Примітка як доказ (GitHub, фото, відео…)" value={o.evidence || ""} disabled={viewOnly} onChange={(e) => toggleObjective(selectedSkill.id, t.level, o.id, "evidence", e.target.value)} />
                                <input type="number" min={1} step={1} className="w-20 text-xs border rounded px-2 py-1 disabled:text-gray-600" title="XP за об'єктив" value={o.xp ?? BASE_OBJECTIVE_XP} disabled={viewOnly} onChange={(e) => toggleObjective(selectedSkill.id, t.level, o.id, "xp", Math.max(1, Number(e.target.value) || BASE_OBJECTIVE_XP))} />
                              </div>
                            </div>
                          </div>
                        </li>
                      ))}
                    </ul>

                    {!viewOnly && (
                      <Button onClick={() => addObjective(selectedSkill.id, t.level)} variant="ghost">+ Додати об'єктив</Button>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}
        </section>
      </main>

      <footer className="max-w-7xl mx-auto px-4 pb-6 text-xs text-gray-500">
        <div className="mt-4">
          <p>Підказка: XP нараховується лише за виконані об'єктиви. Синергія між сферами збільшує XP кожного об'єктива на 15% за сферу (до 45%).</p>
        </div>
      </footer>
    </div>
  );
}
